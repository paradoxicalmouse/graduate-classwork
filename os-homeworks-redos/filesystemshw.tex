\documentclass[12pt,letterpaper]{report}
\usepackage[utf8]{inputenc}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}
\author{Taylor B. Morris}
\title{OS File Systems Homework}
\begin{document}
\makeatletter
{\huge\noindent\@title\large\\\@author\\\@date}
\makeatother
\begin{enumerate}

%Question 1
\item One benefit of contiguous allocation is that read requests are significantly 
faster for requests of sequential blocks as compared to requests of non-sequential 
blocks. Additional benefits is that it would be more memory efficient to keep track of 
all the blocks of a file over separated blocks, as the system then only has to track
one range per file, instead of several. Contiguous allocation is rarely use because
files are commonly deleted and resized, meaning that a contiguous allocation would end
up wasting space - you would need a contiguous block of exactly the right size in order
for the contiguous allocation to work and not be wasting space - i.e. say you have 200
blocks of memory free in a row, but have 190 blocks of information to store there. Now,
you only have 10 blocks of memory free in that location. As that free value gets smaller,
nothing will be able to fill the free space. Repeated several times throughout the drive,
you could end up with hundreds of blocks of wasted memory. Additionally, contiguous
allocation requires there to actually be contiguous blocks, making it difficult to store
information as the drive gets full.

%Question 2
\item File Types: 
\begin{enumerate}[{(Type }1{)}]
\item Regular file: The normal file time. .txt files are an example of this, as are most user files and executables. 
\item Directory: the file that holds the directory structure. Contains information about what files are in that directory.
\item Character device: files which offer non-buffered access to hardware
\item Block device: files which offer buffered access to hardware
\item Named pipe: a file which makes one program's output another programs input - has two "ends" which can be opened from, a read end and a write end.
\item Socket: a file which acts as a network connection.
\item Symbolic link: a soft link to another file. If this link is deleted, the file it points to won't be, unlike a "hard-link"
\end{enumerate}

Data blocks associated with directory files are as follows\\
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Bytes & 0-3 & 4-5 & 6-6 & 7-7 & 8-(8+N-1) \\
\hline
Field & Inode & Size of Entry & Name length & file type & name\\
\hline
\end{tabular}
%Question 3
\item Assuming typical inode structure with 12 direct pointers, 1 indirect, 1 double indirect and 1 triple indirect. First, the 12 direct pointers give us $12 * 2^{10} = 12288$ bytes. Then, the indirect pointer gives us $\frac{1024^2}{4} = 262144$ bytes. Next, the double indirect pointer gives $\frac{1024^3}{4^2} = 67108864$ bytes. Finally, the triple indirect gives $\frac{1024^4}{4^3} = 17179869184$. That leaves us with a total of $17247252480$ bytes.

%Question 4
\item

%Question 5
\item

%Question 6
\item

%Question 7
\item

%Question 8
\item



\end{enumerate}
\end{document}
